[SECTION .data]
GDT_DATA_INDEX equ 2
R3_CODE_GDT_ENTRY_INDEX equ 5
R3_DATA_GDT_ENTRY_INDEX equ 6

R0_DATA_SELECTOR equ GDT_DATA_INDEX << 3
R3_CODE_SELECTOR equ R3_CODE_GDT_ENTRY_INDEX << 3 | 0b011
R3_DATA_SELECTOR equ R3_DATA_GDT_ENTRY_INDEX << 3 | 0b011

[SECTION .text]
[bits 32]

extern alloc_user_page ; 在c中定义，分配用户页
extern free_user_page ; 在c中定义，释放用户页

extern user_entry ; 在c中定义，模拟的用户程序入口
extern update_tss_esp ; 在c中定义，更新tss的栈

extern current_task ; 在c中定义，当前任务
extern exit_current_task ; 在c中定义，退出普通任务，换到idle任务


; ---------------------------------------------------------------------------------------
; 这里是临时程序，目的是从r0内核特权级跳转到r3用户特权级
; ---------------------------------------------------------------------------------------
global move_to_user_mode
move_to_user_mode:
    ; ---------------------------------------------------------------------------------------
    ; 手动模拟切换到用户态，使用中断返回的方式，即从这里出去之后，就不再从这里回来了
    ; ---------------------------------------------------------------------------------------
    ; 要构建的栈结构：
    ; ---------------------------------------------------------------------------------------
    ;     eip          ↑ 低地址（ <-esp 最终栈顶）
    ;     cs           ↑
    ;     eflags       ↑ （栈的增长方向）
    ;     esp          ↑
    ;     ss           ↑ 高地址
    ; ---------------------------------------------------------------------------------------

    ; ---------------------------------------------------------------------------------------
    ; 到用户特权级前更新tss：
    ;   将esp设置为当前任务的，及从用户态通过中断会到内核态之后使用的esp。
    ; ---------------------------------------------------------------------------------------
    push esp
    call update_tss_esp     ; esp0


    ; ---------------------------------------------------------------------------------------
    ; 要进入r3的用户程序，所以使用r3级别的代码段和数据段选择子
    ; 新申请4KB的空间给用户进程, 作为在r3下使用的栈
    ; ---------------------------------------------------------------------------------------
    call alloc_user_page
    add eax, 0x1000

    ; 进入r3用户程序
    push R3_DATA_SELECTOR ; ss
    push eax              ; esp
    pushfd                ; eflags
    push R3_CODE_SELECTOR ; cs
    push user_entry       ; eip
    iret


; ---------------------------------------------------------------------------------------
; 临时程序
; 退出当前用户任务
; ---------------------------------------------------------------------------------------
global exit_user_model
exit_user_model:
    ; -------------------------------------------------------------------------
    ; 恢复内核态段寄存器
    ; -------------------------------------------------------------------------
    mov eax, R0_DATA_SELECTOR
    mov ds, eax
    mov es, eax
    mov fs, eax
    mov gs, eax

    ; -------------------------------------------------------------------------
    ; 用户任务执行完成退出，切换到idel任务执行，就不再回来了
    ; -------------------------------------------------------------------------
    cli ; 关中断，保证顺利到下一个流程
    call exit_current_task ; 任务终止并更新current_task

    ; ---------------------------------------------------------------------------------------
    ; 当前栈结构：
    ; ---------------------------------------------------------------------------------------
    ;     ret          ↑ 从C调用过来压入的返回地址（ <-esp 当前栈顶）
    ; ---------------------------------------------------------------------------------------
    ;     ebx          ↑ 系统调用压入的三个参数
    ;     ecx          ↑
    ;     edx          ↑
    ; ---------------------------------------------------------------------------------------
    ;     eip          ↑ 低地址
    ;     cs           ↑
    ;     eflags       ↑ （栈的增长方向）
    ;     esp          ↑
    ;     ss           ↑ 高地址
    ; ---------------------------------------------------------------------------------------

    ; 回收用户栈空间
    mov eax, [esp + 7 * 4] ; 取到r3的esp
    and eax, 0xFFFFF000 ; 分配的一页4k内存，低12位清零即为虚拟页地址
    push eax
    call free_user_page

    mov eax, [current_task] ; 后续即进入0号任务恢复流程

    ; -------------------------------------------------------------------
    ; 恢复任务上下文。
    ; -------------------------------------------------------------------
    mov edi, [eax + 17 * 4]
    mov esi, [eax + 16 * 4]
    mov ebp, [eax + 15 * 4]
    ;mov esp, [eax + 14 * 4] ; 当前esp不再使用，这里将esp退回到原栈，即任务执行结束后，栈会平到新任务执行结束处，而非回到这里的栈
    mov ebx, [eax + 13 * 4]
    mov edx, [eax + 12 * 4]
    ; mov ecx, [eax + 11 * 4]
    ; mov eax, [eax + 10 * 4]

    ; -----------------------------------------------------------
    ; 手动模拟中断返回，即切换到原来的场景
    ; -----------------------------------------------------------
    ; 要构建的栈结构：
    ; -----------------------------------------------------------
    ;     eip          ↑ 低地址（ <-esp 最终栈顶 = tss.esp）
    ;     cs           ↑（栈的增长方向）
    ;     eflags       ↑ 高地址
    ; -----------------------------------------------------------

    ; esp (r0)
    mov ecx, [eax + 14 * 4]
    add ecx, 3 * 4
    mov esp, ecx

    ; eflags
    mov ecx, [eax + 9 * 4]
    push ecx
    ; cs
    mov ecx, [eax + 19 * 4]
    push ecx
    ; eip
    mov ecx, [eax + 8 * 4]
    push ecx

    ; ------------------------------------------------------------
    ; 栈侯建完成，恢复临时使用的所有寄存器
    ; ------------------------------------------------------------
    mov ecx, [eax + 11 * 4]
    mov eax, [eax + 10 * 4]

    ; 以中断返回的方式跳转，不会再回来了
    iret
