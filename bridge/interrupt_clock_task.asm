[SECTION .data]
TSS_STRUCT_SIZE equ 27 << 2 ; tss_t 占用字节数

; ---------------------------------------------------------------------------------------
; GDT定义参考 gdt.c
; ---------------------------------------------------------------------------------------

R0_DATA_GDT_ENTRY_INDEX equ 2
R3_CODE_GDT_ENTRY_INDEX equ 5
R3_DATA_GDT_ENTRY_INDEX equ 6

R0_DATA_SELECTOR equ R0_DATA_GDT_ENTRY_INDEX << 3
R3_CODE_SELECTOR equ R3_CODE_GDT_ENTRY_INDEX << 3 | 0b011
R3_DATA_SELECTOR equ R3_DATA_GDT_ENTRY_INDEX << 3 | 0b011

[SECTION .text]
[bits 32]

extern current_task         ; 在c中定义，当前任务
extern task_scheduler_ticks ; 在c中定义，进行一次任务调度滴答
extern exit_current_task    ; 在c中定义，退出普通任务，换到idle任务

extern process_activate     ; 在c中定义，激活用户页表，如果是用户进程还会更新tss的栈
extern alloc_user_page      ; 在c中定义，分配用户页
extern free_user_page       ; 在c中定义，释放用户页
extern process_destroy      ; 在c中定义，释放用户进程页表

; ---------------------------------------------------------------------------------------
; 时钟中断处理函数
; ---------------------------------------------------------------------------------------
; 初始栈结构（摘自 interrupt.asm）:
; -----------------------------------------------------
;     eip          ↑ 低地址（ <-esp 当前栈顶）
;     cs           ↑
;     eflags       ↑ （栈的增长方向）
;     (esp)        ↑ 注：从这里开始往下 ↓ 是发生态切换时额外压入的两个值
;     (ss)         ↑ 高地址
; ---------------------------------------------------------------------------------------
global interrupt_handler_clock
interrupt_handler_clock:
    ; 保存ecx，用其做临时变量
    push ecx

    ; ---------------------------------------------------------------------------------------
    ; 恢复内核态段寄存器
    ; ---------------------------------------------------------------------------------------
    ; 从内核态进入用户态时，为了安全，CPU会将段寄存器 ds、es、fs、gs 置0，即指向0全局描述符，
    ; 目的就是为了防止在用户态通过内核段寄存器访问内核数据，所以从用户态中断进入到这里时，这些段寄存器依然是0
    ; ---------------------------------------------------------------------------------------
    ; 因为获取任务首先就要用到ds段寄存器，所以第一步就是确保段寄存器没问题
    ; 但这里并不通过段寄存器是否为0作为确认从用户态到内核态的逻辑，用户态后面会用cs做TPL特权级检查
    ; ---------------------------------------------------------------------------------------
    ; 这里为了简单就直接赋值了，因为内核态的段选择子也是固定的。
    ; ---------------------------------------------------------------------------------------
    mov ecx, R0_DATA_SELECTOR
    mov ds, ecx
    mov es, ecx
    mov fs, ecx
    mov gs, ecx

    ; 先看当前有没有调度的任务，即是否首次调度任务
    mov ecx, [current_task]
    cmp ecx, 0
    je .store_env_end ; 无需保存上下文环境

.store_env:

    ; -------------------------------------------------------------------
    ; 保存原程序环境，即：初始栈中的寄存器+通用寄存器(pushad)
    ; 保存到 current_task 的 tss 结构中，参考 task.h 的 tss_t 结构定义
    ; -------------------------------------------------------------------
    ; 中断栈结构和pushad结构参考 interrupt.asm 中的中断定义
    ; -------------------------------------------------------------------

    ; 依次保存
    mov [ecx + 17 * 4], edi
    mov [ecx + 16 * 4], esi
    mov [ecx + 15 * 4], ebp
    ; mov [eax + 14 * 4], esp
    mov [ecx + 13 * 4], ebx
    mov [ecx + 12 * 4], edx
    ; mov [ecx + 11 * 4], ecx
    mov [ecx + 10 * 4], eax

    ; ---------------------------------------------------------------------------------------
    ; 当前栈结构
    ; ---------------------------------------------------------------------------------------
    ;     ecx          ↑ 低地址（ <-esp 当前栈顶）
    ; ----------------------------------------
    ;     eip          ↑ （栈的增长方向）
    ;     cs           ↑
    ;     eflags       ↑
    ;     (esp)        ↑
    ;     (ss)         ↑ 高地址
    ; ---------------------------------------------------------------------------------------

    ; eip
    mov eax, [esp + 4]
    mov [ecx + 8 * 4], eax

    ; eflags
    mov eax, [esp + 0x0C]
    mov [ecx + 9 * 4], eax

    ; cs
    mov eax, [esp + 8]
    mov [ecx + 19 * 4], eax

    ; -------------------------------------------------------------------
    ; 这里要看是否是用户进程过来的，是的话还要保存r3的ss:esp, 并修复r0的esp
    ; -------------------------------------------------------------------
    and eax, 0x3    ; 检查cs
    jz .store_user_env_end
    ; esp (r3)
    mov eax, [esp + 0x10]
    mov [ecx + 1 * 4], eax
    ; ss (r3)
    mov eax, [esp + 0x14]
    mov [ecx + 2 * 4], eax
.store_user_env_end:

    ; 用eax把ecx换下来
    mov eax, ecx
    pop ecx ; 恢复 ecx 和 esp
    mov [eax + 11 * 4], ecx
    mov [eax + 14 * 4], esp

    ; 恢复eax
    mov eax, [ecx + 10 * 4]

    jmp .start_task_scheduler

.store_env_end:
    pop ecx

.start_task_scheduler:
    ; ---------------------------------------------------------------------------------------
    ; 这里以上都是保存任务状态，到这里所有寄存器和栈都已恢复
    ; ---------------------------------------------------------------------------------------
    ; 开始进行一次任务调度滴答，会更新当前任务
    ; ---------------------------------------------------------------------------------------
    ; 当前栈结构:
    ; ----------------------------------------
    ;     eip          ↑ 低地址（ <-esp 当前栈顶）
    ;     cs           ↑
    ;     eflags       ↑ （栈的增长方向）
    ;     (esp)        ↑
    ;     (ss)         ↑ 高地址
    ; ---------------------------------------------------------------------------------------

    push eax
    call task_scheduler_ticks

    ; 检查任务
    mov eax, [current_task]
    cmp eax, 0
    je .exit_due_to_no_tasks ; 没有可调度任务，直接哪儿来的回哪儿去（idle任务会一直在，只有测试时才会让idle结束）

.start_processing_task:
    ; 开始处理任务，先保存要用的寄存器
    push ecx

    ; ---------------------------------------------------------------------------------------
    ; 当前栈结构
    ; ---------------------------------------------------------------------------------------
    ;     ecx          ↑ 低地址（ <-esp 当前栈顶）
    ;     eax          ↑
    ; ----------------------------------------
    ;     eip          ↑ ( <-esp 已保存到tss的对应栈顶)
    ;     cs           ↑
    ;     eflags       ↑ （栈的增长方向）
    ;     (esp)        ↑
    ;     (ss)         ↑ 高地址
    ; ---------------------------------------------------------------------------------------

    ; 检查是否首次调度
    mov ecx, [eax + TSS_STRUCT_SIZE + 2 * 4] ; 总调度次数
    cmp ecx, 1
    jne .recover_env ; 旧任务需恢复上下文环境 （暂不考虑调度次数超过0xFFFFFFFF后归0的情况, 10ms一次归零也需要497天）

.run_new_task:
    ; -------------------------------------------------------------------------
    ; 新任务执行
    ; -------------------------------------------------------------------------
    ; 每个内核任务（内核线程、用户进程）都有自己的内核任务栈，
    ; 保存当前任务esp，启用新任务esp
    ; -------------------------------------------------------------------------
    ; 如果是目标仍是内核态，转到具体任务方法执行即可
    ; 如果是目标是用户态，则需要模拟中断返回的方式进入
    ; -------------------------------------------------------------------------

    mov ecx, [eax + TSS_STRUCT_SIZE + 4 * 4] ; pgdir
    cmp ecx, 0
    jz .run_kernel_new_task ; 如果没有页目录表，说明是内核任务

.run_user_new_task:
    push ebx
    ; ---------------------------------------------------------------------------------------
    ; 当前栈结构
    ; ---------------------------------------------------------------------------------------
    ;     ebx          ↑ 低地址（ <-esp 当前使用的栈顶）
    ;     ecx          ↑
    ;     eax          ↑
    ; ----------------------------------------
    ;     eip          ↑ ( <-esp 已保存到tss的对应栈顶)
    ;     cs           ↑
    ;     eflags       ↑（栈的增长方向）
    ;     (esp)        ↑
    ;     (ss)         ↑ 高地址
    ; ---------------------------------------------------------------------------------------

    ; ---------------------------------------------------------------------------------------
    ; 进入r3用户程序，手动模拟切换到用户态，使用中断返回的方式，即从这里出去之后，就不再从这里回来了
    ; ---------------------------------------------------------------------------------------
    ; 由于中断不再返回，所以在跳转时要恢复进入这里之前的任务的所有寄存器状态，所以，按以下步骤执行：
    ;     1, 切换到用户进程的内核栈，并将临时使用且最后需要恢复的所有寄存器转存
    ;     2, 在用户进程自己的内核栈构建要跳转到用户进程的数据
    ;     3, 恢复所有寄存器
    ;     4, 以终中断返回的方式转移到用户态
    ; ---------------------------------------------------------------------------------------
    mov ebx, esp                             ; 暂存当前栈
    mov esp, [eax + TSS_STRUCT_SIZE + 3 * 4] ; 切到任务自己的内核栈
    ; 转存数据
    mov ecx, [ebx + 8]  ; eax
    push ecx
    mov ecx, [ebx + 4]  ; ecx
    push ecx
    mov ecx, [ebx]      ; ebx
    push ecx
    ; ---------------------------------------------------------------------------------------
    ; 到这里已经开始用用户进程自己的内核栈了，原任务栈已经不用了
    ; ---------------------------------------------------------------------------------------
    ; 当前栈结构
    ; ----------------------------------------------------
    ;     ebx          ↑ 低地址（ <-esp 当前栈顶）
    ;     ecx          ↑（栈的增长方向）
    ;     eax          ↑ 高地址
    ; ---------------------------------------------------------------------------------------

    ; ---------------------------------------------------------------------------------------
    ; 到用户特权级前激活用户页表，并更新esp0：
    ;      tss会设置为用户进程内核栈的栈顶, 即esp0取任务中的kstack字段
    ;      即无论这里的内核栈怎么构建，进入用户进程后，其内核栈都会平到对应栈顶
    ;      所以上面压入的三个临时值也不用管，直接在此基础上构建跳转参数即可
    ; ---------------------------------------------------------------------------------------
    push eax    ; 作为参数，也先暂存
    call process_activate

    ; ---------------------------------------------------------------------------------------
    ; 到这里已经启用用户页目录表了，就可以申请该用户进程下专有虚拟地址了，
    ; 新申请4KB的空间给用户进程, 作为在r3下使用的栈
    ; ---------------------------------------------------------------------------------------
    call alloc_user_page
    add eax, 0x1000     ; r3 esp
    mov ecx, eax

    pop eax     ; 恢复eax为current_task

    ; ---------------------------------------------------------------------------------------
    ; 要构建的栈结构（也是进程任务栈跳转前的初始内核栈结构）：
    ; ---------------------------------------------------------------------------------------
    ;     eip          ↑ 低地址（ <-esp 最终栈顶）
    ;     cs           ↑
    ;     eflags       ↑ （栈的增长方向）
    ;     esp          ↑
    ;     ss           ↑ 高地址
    ; ----------------------------------------------------
    ;     ebx          ↑ 低地址（ <-esp 当前栈顶）
    ;     ecx          ↑（栈的增长方向）
    ;     eax          ↑ 高地址
    ; ---------------------------------------------------------------------------------------
    ; 要进入r3的用户程序，所以使用r3级别的代码段和数据段选择子
    ; ---------------------------------------------------------------------------------------
    push R3_DATA_SELECTOR ; ss
    push ecx              ; esp
    pushfd                ; eflags (初始不允许中断)
    pop ecx               ; eflags（取出）
    or ecx, 0x200         ; eflags（修改IF位）
    push ecx              ; eflags (重设，即跳转后允许中断)
    push R3_CODE_SELECTOR ; cs
    mov ecx, [eax + TSS_STRUCT_SIZE + 4]     ; func
    push ecx              ; eip

    ; ---------------------------------------------------------------------------------------
    ; 构建完成，恢复所有寄存器, 并进入用户模式
    ; ---------------------------------------------------------------------------------------
    mov ebx, [esp + 5 * 4]
    mov ecx, [esp + 6 * 4]
    mov eax, [esp + 7 * 4]

    iret ; 正式进入用户态，不会从这里回来了

.run_kernel_new_task:
    pop ecx
    ; ---------------------------------------------------------------------------------------
    ; 当前栈结构
    ; ---------------------------------------------------------------------------------------
    ;     eax          ↑ 低地址（ <-esp 当前使用的栈顶）
    ; ----------------------------------------
    ;     eip          ↑ ( <-esp 已保存到tss的对应栈顶)
    ;     cs           ↑
    ;     eflags       ↑（栈的增长方向）
    ;     (esp)        ↑
    ;     (ss)         ↑ 高地址
    ; ---------------------------------------------------------------------------------------

    mov [eax + 26 * 4], esp                  ; ssp, 保存当前栈（只有idle任务中的这个字段有意义, 用于0号任务结束后回到main）
    mov esp, [eax + TSS_STRUCT_SIZE + 3 * 4] ; 切到任务自己的内核任务栈
    mov eax, [eax + TSS_STRUCT_SIZE + 4]     ; func
    sti                                      ; 允许中断
    call eax                                 ; 任务开始执行

.run_task_end:
    ; -------------------------------------------------------------------------
    ; 任务执行完成
    ; -------------------------------------------------------------------------
    ; 所有任务都是直接或间接由idle任务（0号任务）启动的，
    ; 除idle外，其他任务都可能会随时执行结束，
    ; 所以普通任务执行完毕，是不可以中断返回的，因为很可能回到已经被释放的错误地址，
    ; 而且，目前要结束当前任务，即当前任务栈也需要销毁，
    ; 所以，要有栈可用，要么恢复idle任务执行，要么建新任务用新任务栈，
    ; 这里为了统一流程，还是交由idle处理
    ; -------------------------------------------------------------------------
    cli ; 关中断，保证顺利到下一个流程
    push ecx ; 这里是暂存到任务的内核栈

    mov eax, [current_task]
    mov ecx, [eax + TSS_STRUCT_SIZE] ; pid
    cmp ecx, 0
    je .exit_idle_task ; idle 任务的终止，直接退回到main

    ; 普通任务终止
    call exit_current_task
    mov eax, [current_task] ; 后续即进入0号任务恢复流程

.recover_env:

    ; -------------------------------------------------------------------
    ; 恢复任务上下文。
    ; -------------------------------------------------------------------
    ; 这里的主要任务就是恢复到之前的任务，并且不再回来，
    ; 即栈要恢复到创建任务时的栈，代码要跳转该任务到第一次中断时的地方。
    ; -------------------------------------------------------------------

    mov edi, [eax + 17 * 4]
    mov esi, [eax + 16 * 4]
    mov ebp, [eax + 15 * 4]
    mov esp, [eax + 14 * 4] ; 当前esp不再使用，这里将esp退回到原栈，即任务执行结束后，栈会平到新任务执行结束处，而非回到这里的栈
    mov ebx, [eax + 13 * 4]
    mov edx, [eax + 12 * 4]
    ; mov ecx, [eax + 11 * 4]
    ; mov eax, [eax + 10 * 4]

    ; ---------------------------------------------------------------------------------------
    ; 手动模拟中断返回，即切换到原来的场景
    ; ---------------------------------------------------------------------------------------
    ; 要构建的栈结构：
    ; -----------------------------------------------------------
    ;     eip          ↑ 低地址（ <-esp 最终栈顶 = tss.esp）
    ;     cs           ↑（栈的增长方向）
    ;     eflags       ↑ 高地址
    ;     (esp)        ↑ (用户程序还需要下面这两个)
    ;     (ss)         ↑ 高地址
    ; ---------------------------------------------------------------------------------------
    ; 注意，这个构建要保证在完成时，esp和现在的值（tss中保存的）相等，即完全还原到之前的状态，
    ; 因为在中断保存上下文时，本身esp的状态已经处于指向了压入3或5个寄存器的栈，
    ; 所以这里要从中断前模拟，即先退回esp，这样才是完全恢复
    ; ---------------------------------------------------------------------------------------
    add esp, 3 * 4  ; 先假设是压入3个寄存器

    ; -------------------------------------------------------------------
    ; 检查，如果是恢复用户进程的任务，还需要压入r3的ss和esp
    ; -------------------------------------------------------------------
    mov ecx, [eax + 19 * 4] ; cs
    and ecx, 0x3
    jz .skip_recover_user_env
    add esp, 2 * 4  ; 补充为压入5个寄存器
    ; ss
    mov ecx, [eax + 2 * 4]
    push ecx
    ; esp
    mov ecx, [eax + 1 * 4]
    push ecx

.skip_recover_user_env:

    ; eflags
    mov ecx, [eax + 9 * 4]
    push ecx
    ; cs
    mov ecx, [eax + 19 * 4]
    push ecx
    ; eip
    mov ecx, [eax + 8 * 4]
    push ecx

    ; 恢复当前任务的页目录表
    push eax
    call process_activate
    pop eax

    ; ------------------------------------------------------------
    ; 栈侯建完成，恢复临时使用的所有寄存器
    ; ------------------------------------------------------------
    mov ecx, [eax + 11 * 4]
    mov eax, [eax + 10 * 4]

    ; 以中断返回的方式跳转，不会再回来了
    iret

.exit_idle_task:
    ; ------------------------------------------------------------
    ; 到这里还是用的任务的栈，并且eax和ecx还没有恢复
    ; ------------------------------------------------------------
    ; 先将ecx从任务的栈中恢复，
    ; 再结束任务，并返回原来的中断栈，用于恢复
    ; ------------------------------------------------------------

    pop ecx
    call exit_current_task   ; 返回 ssp 在 eax 中
    mov esp, eax

    ; ---------------------------------------------------------------------------------------
    ; 到这里已经恢复到中断栈了，只剩下eax没有恢复
    ; ---------------------------------------------------------------------------------------
    ; 当前栈结构
    ; ---------------------------------------------------------------------------------------
    ;     eax          ↑ 低地址（ <-esp 当前栈顶）
    ; ----------------------------------------
    ;     eip          ↑ （栈的增长方向）
    ;     cs           ↑
    ;     eflags       ↑
    ;     (esp)        ↑
    ;     (ss)         ↑ 高地址
    ; ---------------------------------------------------------------------------------------

.exit_due_to_no_tasks:
    pop eax
    iret


; ---------------------------------------------------------------------------------------
; 退出当前用户进程，由用户态通过系统调用发起
; ---------------------------------------------------------------------------------------
; 本想放到 interrupt_syscall.asm 中，但是为了任务的生命周期完整性，还是考虑放在这里
; 从这里开始，也从这里结束，
; 所以当前这个文件，系统时钟中断只是个任务程序调度的入口，其真实作用还是任务调度，管理任务的全生命周期
; ---------------------------------------------------------------------------------------
global exit_user_model
exit_user_model:
    ; -------------------------------------------------------------------------
    ; 恢复内核态段寄存器
    ; -------------------------------------------------------------------------
    mov eax, R0_DATA_SELECTOR
    mov ds, eax
    mov es, eax
    mov fs, eax
    mov gs, eax

    ; -------------------------------------------------------------------------
    ; 用户任务执行完成退出，切换到idel任务执行，就不再回来了
    ; -------------------------------------------------------------------------
    cli ; 关中断，保证顺利到下一个流程

    ; ---------------------------------------------------------------------------------------
    ; 当前用户进程的内核栈结构：
    ; ---------------------------------------------------------------------------------------
    ;     ret          ↑ 从C调用过来压入的返回地址（ <-esp 当前栈顶）
    ; ---------------------------------------------------------------------------------------
    ;     ebx          ↑ 系统调用压入的三个参数
    ;     ecx          ↑
    ;     edx          ↑
    ; ---------------------------------------------------------------------------------------
    ;     eip          ↑ 低地址
    ;     cs           ↑
    ;     eflags       ↑ （栈的增长方向）
    ;     esp          ↑
    ;     ss           ↑ 高地址
    ; ---------------------------------------------------------------------------------------

    ; 先回收用户的r3栈空间
    mov eax, [esp + 7 * 4]  ; 取到r3的esp
    sub eax, 1              ; 确保用户栈不是指向4KB最高地址的栈顶
    and eax, 0xFFFFF000     ; 分配的一页4k内存，低12位清零即为虚拟页地址
    push eax                ; 这里使用的是用户进程的内核栈，等会就全释放了，所以不用考虑恢复栈的问题
    call free_user_page

    ; 再释放用户页表
    mov eax, [current_task]
    push eax
    call process_destroy

    ; 再终止任务并更新current_task（变为idle任务）
    call exit_current_task

    ; -------------------------------------------------------------------
    ; 进入恢复0号任务流程
    ; -------------------------------------------------------------------
    mov eax, [current_task]

    ; -------------------------------------------------------------------
    ; 恢复上下文
    ; -------------------------------------------------------------------
    mov edi, [eax + 17 * 4]
    mov esi, [eax + 16 * 4]
    mov ebp, [eax + 15 * 4]
    ; mov esp, [eax + 14 * 4]
    mov ebx, [eax + 13 * 4]
    mov edx, [eax + 12 * 4]
    ; mov ecx, [eax + 11 * 4]
    ; mov eax, [eax + 10 * 4]

    ; -----------------------------------------------------------
    ; 手动模拟中断返回，即切换到idle任务原来的场景
    ; -----------------------------------------------------------
    ; 要构建的栈结构：
    ; -----------------------------------------------------------
    ;     eip          ↑ 低地址（ <-esp 最终栈顶 = tss.esp）
    ;     cs           ↑（栈的增长方向）
    ;     eflags       ↑ 高地址
    ; -----------------------------------------------------------

    ; esp (idle)
    mov ecx, [eax + 14 * 4]
    add ecx, 3 * 4 ; idle任务暂停的时候esp肯定是已经有了3个值的，这里手动平栈恢复
    mov esp, ecx   ; 用户进程的内核栈不再使用，这里将esp退回到(idle)原栈

    ; eflags
    mov ecx, [eax + 9 * 4]
    push ecx
    ; cs
    mov ecx, [eax + 19 * 4]
    push ecx
    ; eip
    mov ecx, [eax + 8 * 4]
    push ecx

    ; -------------------------------------------------------------------
    ; 恢复内核页目录表
    ; -------------------------------------------------------------------
    push eax
    call process_activate
    pop eax

    ; ------------------------------------------------------------
    ; 栈构建完成，恢复临时使用的所有寄存器（恢复idle暂停前的所有寄存器）
    ; ------------------------------------------------------------
    mov ecx, [eax + 11 * 4]
    mov eax, [eax + 10 * 4]

    ; 以中断返回的方式跳转，不会再回来了
    iret
