ORG 0x500

; ------------------------------------------------------------------------------------------------------
; 定义 GDT 描述符属性
; ------------------------------------------------------------------------------------------------------
; 段描述符格式：
;    总占8字节，以下高低32位为人为划分，其实就是一段连续的8字节空间。
;    其中，段基址32位，位于低32位的16~31位，高32位的0~7和24~31位。
;    段界限20位（寻址范围范围1MB或4GB），位于低32位的0~15位，高32位的16~19位。
; 高32位：
;     -------------------------------------------------------------------------------------------------
;     | 31  | 30  | 29  | 28  | 27  | 26  | 25  | 24  | 23  | 22  | 21  | 20  | 19  | 18  | 17  | 16  |
;     |                 段基址的24~31位                 |  G  | D/B |  L  | AVL |      段界限的16~19位   |
;     -------------------------------------------------------------------------------------------------
;     -------------------------------------------------------------------------------------------------
;     | 15  | 14  | 13  | 12  | 11  | 10  |  9  |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
;     |  P  |    DPL    |  S  |         TYPE          |               段基址的16~23位                   |
;     -------------------------------------------------------------------------------------------------
; 低32位：
;     -------------------------------------------------------------------------------------------------
;     | 31  | 30  | 29  | 28  | 27  | 26  | 25  | 24  | 23  | 22  | 21  | 20  | 19  | 18  | 17  | 16  |
;     |                                          段基址的0~15位                                         |
;     -------------------------------------------------------------------------------------------------
;     -------------------------------------------------------------------------------------------------
;     | 15  | 14  | 13  | 12  | 11  | 10  |  9  |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
;     |                                          段界限的0~15位                                         |
;     -------------------------------------------------------------------------------------------------
; ------------------------------------------------------------------------------------------------------
; G:
;     定义段界限粒度：0-单位1B（即段界限1M），1-单位4K（即段界限4G）
; D/B:
;     代码段（使用D位）：
;        0-指令有效地址和草数据为16位，指令使用IP寄存器。
;        1-指令有效地址和草数据为32位，指令使用EIP寄存器。
;     栈段（使用B位）：
;        0-使用SP寄存器，栈的起始地址为16位寄存器的最大寻址范围0xFFFF。
;        1-使用ESP寄存器，栈的起始地址为32位寄存器的最大寻址范围0xFFFFFFFF。
; L:
;     保留位：0-32位代码段，1-64位代码段。
; AVL:
;     Available, 硬件对其没有专门的用途，操作系统可随意使用。
; P:
;     Present, 0-不存在于内存中（段异常），1-段存在于内存中
;     CPU检测到P值为0时，会转到异常处理程序，在处理完成后要将其置为1
; DPL:
;     Descriptor Privilege Level, 即段描述符特权级，0~3四种特权级，数字越小特权级越大。
;     一般情况下，操作系统处于最高的0特权级，用户程序处于最低的3特权级，某些指令仅在0特权级下才能执行。
; S:
;     0-系统段（也叫代码段，硬件相关），1-非系统段（也叫数据段，软件相关，包括操作系统）
; TYPE:
;     系统段结构（S=0）：
;        略
;     非系统段结构（S=1）：
;        以下结构中的通用参数说明：
;            第0位A位，表示Accessed位，由CPU设置，每当该段被CPU访问后CPU就将其置1，新建段描述符时应将其置零
;            第3位X位，表示Executable位，标识是否是可执行的代码，1为可执行
;        内存段类型=代码段:
;            -------------------------
;            |  3  |  2  |  1  |  0  |
;            -------------------------
;            |  X  |  R  |  C  |  A  |
;            ------------------------- --- 说明 ---
;            |  1  |  0  |  0  |  *  |   只执行代码段
;            |  1  |  1  |  0  |  *  |   可执行、可读代码段
;            |  1  |  0  |  1  |  *  |   可执行、一致性代码段
;            |  1  |  1  |  1  |  *  |   可执行、可读、一致性代码段
;            ------------------------- -------------------------
;            部分参数说明：
;               C: conforming，一致性代码段，也称依从代码段，即作为转移的目标段时，特权级是否和转移前的低特权级保持一致
;            ---------------------------------------------------
;        内存段类型=数据段:
;            -------------------------
;            |  3  |  2  |  1  |  0  |
;            -------------------------
;            |  X  |  W  |  E  |  A  |
;            ------------------------- --- 说明 ---
;            |  0  |  0  |  0  |  *  |   只读数据段
;            |  0  |  1  |  0  |  *  |   可读写数据段
;            |  0  |  0  |  1  |  *  |   只读，向下扩展的数据段
;            |  0  |  1  |  1  |  *  |   可读写，向下扩展的数据段
;            ------------------------- -------------------------
;            部分参数说明：
;               W: Writable，段是否可写
;               E: Extend，标识段的扩展方向，0为向上扩展（通常用于代码段和数据段），1为向下（通常用于栈段）。
;                           该扩展方向只是为了指导段界限检测的方式，和使用push指令时SP的方向无关。
;                           向上扩展的检测方式为: 偏移地址+数据长度-1<=实际段界限大小
;                           向下扩展的检测方式为: 实际段界限大小<esp-操作数大小<=栈指针最大可访问地址（如B位为1时即32位最大可访问地址为0xFFFFFFFF）
;            ---------------------------------------------------
;        段寄存器使用时的段类型检查:
;           代码段(X=1)：
;               ----------------------
;               | TYPE | R=1  | R=1  |
;               ----------------------
;               |  CS  |     ok      |
;               |  DS  |  no  |  ok  |
;               |  ES  |  no  |  ok  |
;               |  FS  |  no  |  ok  |
;               |  GS  |  no  |  ok  |
;               |  SS  |     no      |
;               ----------------------
;           数据段(X=0)：
;               ----------------------
;               | TYPE | W=0  | W=1  |
;               ----------------------
;               |  CS  |     no      |
;               |  DS  |     ok      |
;               |  ES  |     ok      |
;               |  FS  |     ok      |
;               |  GS  |     ok      |
;               |  SS  |  no  |  ok  |
;               ----------------------
; ------------------------------------------------------------------------------------------------------
[SECTION .gdt]

DESC_G_4k equ 1<<23
DESC_D_32 equ 1<<22
DESC_L    equ 0<<21
DESC_AVL  equ 0<<20
; 定义四种类型的LIMIT（段界限的第二段，16~19位）
DESC_LIMIT_2_CODE   equ 0xF << 16
DESC_LIMIT_2_DATA   equ 0xF << 16
DESC_LIMIT_2_STACK  equ 0xF << 16
DESC_LIMIT_2_SCREEN equ 0x0 << 16

DESC_P equ 1<<15
; 定义四种特权级
DESC_DPL_0 equ 00b<<13
DESC_DPL_1 equ 01b<<13
DESC_DPL_2 equ 10b<<13
DESC_DPL_3 equ 11b<<13

DESC_S_NOT_SYS equ 1<<12
; 定义四种类型的TYPE（SCREEN按DATA处理）
DESC_TYPE_CODE   equ 1000b<<8 ; X=1, R=0, C=0, A=0，代码段可执行，非一致性，不可读，访问位清零
DESC_TYPE_DATA   equ 0010b<<8 ; X=0, R=0, C=1, A=0，数据段不可执行，向上扩展，可写，访问位清零
DESC_TYPE_STACK  equ 0110b<<8 ; X=0, R=1, C=1, A=0，栈段不可执行，向下扩展，可写，访问位清零
DESC_TYPE_SCREEN equ DESC_TYPE_DATA ; 和数据段保持一致

; ------------------------------------------------------------------------------------------------------
; 整合四种类型的高四字节和低四字节
; 屏幕段基址为0xb8000, 其他段基址为0
; 屏幕段界限为0x7fff>>12, 其他段界限为4G>>12
; ------------------------------------------------------------------------------------------------------
DESC_CODE_HIGH4   equ (0x00<<24) + DESC_G_4k + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_2_CODE   + DESC_P + DESC_DPL_0 + DESC_S_NOT_SYS + DESC_TYPE_CODE   + 0x00
DESC_DATA_HIGH4   equ (0x00<<24) + DESC_G_4k + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_2_DATA   + DESC_P + DESC_DPL_0 + DESC_S_NOT_SYS + DESC_TYPE_DATA   + 0x00
DESC_STACK_HIGH4  equ (0x00<<24) + DESC_G_4k + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_2_STACK  + DESC_P + DESC_DPL_0 + DESC_S_NOT_SYS + DESC_TYPE_STACK  + 0x00
DESC_SCREEN_HIGH4 equ (0x00<<24) + DESC_G_4k + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_2_SCREEN + DESC_P + DESC_DPL_0 + DESC_S_NOT_SYS + DESC_TYPE_SCREEN + 0x0B

DESC_CODE_LOW4   equ 0x0000FFFF
DESC_DATA_LOW4   equ 0x0000FFFF
DESC_STACK_LOW4  equ 0x0000FFFF
DESC_SCREEN_LOW4 equ 0x80000007 ; 段基址=0xb8000，粒度1B的情况下段界限0xbffff-0xb8000=0x7fff，粒度4K的情况下段界限0x7fff/4K=0x7fff>>12=0x7

    ; ------------------------------------------------------------------------------------------------------
    ; ---------------------------------------   构建GDT及其内部描述符   ---------------------------------------
    ; ------------------------------------------------------------------------------------------------------
GDT_BASE: ; index=0, 第0个描述符为空描述符
    dd 0x00000000
    dd 0x00000000
GDT_CODE: ; index=1, 定义代码 段描述符
    dd DESC_CODE_LOW4
    dd DESC_CODE_HIGH4
GDT_DATA: ; index=2, 定义数据 段描述符
    dd DESC_DATA_LOW4
    dd DESC_DATA_HIGH4
GDT_STACK: ; index=3, 定义栈 段描述符
    dd DESC_STACK_LOW4
    dd DESC_STACK_HIGH4
GDT_SCREEN: ; index=4, 定义屏幕 段描述符
    dd DESC_SCREEN_LOW4
    dd DESC_SCREEN_HIGH4
GDT_RESERVED:
    times 10 dq 0 ; 预留10个描述符空位

; ------------------------------------------------------------------------------------------------------
; 定义gdtr指向的48位内存数据结构：
;     -------------------------------------------------------------------------------
;     | 47  |  ...    ...    ...    ...    ...  |  16  |    15  |  ...   ...  |  0  |
;     |                GDT内存起始地址                   |            GDT界限          |
;     -------------------------------------------------------------------------------
; ------------------------------------------------------------------------------------------------------
GDT_SIZE equ $ - GDT_BASE
GDT_LIMIT equ GDT_SIZE - 1
gdt_ptr:
    dw GDT_LIMIT
    dd GDT_BASE


; ------------------------------------------------------------------------------------------------------
; 定义 Sector 选择子属性
; ------------------------------------------------------------------------------------------------------
; 结构：
;     -------------------------------------------------------------------------------------------------
;     | 15  | 14  | 13  | 12  | 11  | 10  |  9  |  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
;     |                                     描述符索引值                              | TI  |    RPL    |
;     -------------------------------------------------------------------------------------------------
; ------------------------------------------------------------------------------------------------------
; RPL:
;     Request Privilege Level, 请求特权级，0~3
; TI:
;     Table Indicator, 0-在GDT中索引描述符，1-在LDT中索引描述符
; 描述符索引值:
;     规定GDT中的第0个描述符是空描述符，如果选择子的索引值为0则会引用到它。
;     所以，不允许往CS和SS段寄存器中加载索引值为0的选择子。
;     虽然可以往DS、ES、FS、GS寄存器中加载值为0的选择子，但真正在使用时CPU将会抛出异常，毕竟第0个段描述符是哑的，不可用。
;     如果索引值超出描述符表（是GDT还是LDT由TI位决定）定义的界限值也会抛出异常。
; ------------------------------------------------------------------------------------------------------
[SECTION .selector]

; 定义四种特权级
RPL_0 equ 00b
RPL_1 equ 01b
RPL_2 equ 10b
RPL_3 equ 11b

TI_GDT equ 000b
TI_LDT equ 100b

; --------------------------------------------
; ---------------   定义选择子   ---------------
; --------------------------------------------
SELECTOR_CODE   equ 1<<3 + TI_GDT + RPL_0
SELECTOR_DATA   equ 2<<3 + TI_GDT + RPL_0
SELECTOR_STACK  equ 3<<3 + TI_GDT + RPL_0
SELECTOR_SCREEN equ 4<<3 + TI_GDT + RPL_0


[SECTION .data]
TOC_ADDR equ 0x1500
TOC_SECTOR_START equ 5
TOC_SECTOR_NUM equ 60

msg:
    db "breaking through 512 bytes!", 10, 13, 0

[SECTION .text]
[BITS 16]
global loader_start
loader_start:
    ; 初始化段寄存器
    mov ax, 0
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax

    mov     si, msg
    call    print

    ; ------------------------------------------------------------------------------------------------------
    ; -----------------------------------------   准备进入保护模式   ------------------------------------------
    ; ------------------------------------------------------------------------------------------------------

    ; 关中断
    cli

    ; 开启A20
    in al, 0x92
    or al, 0000_0010b
    out 0x92, al

    ; 加载GDT
    lgdt [gdt_ptr]

    ; 设置保护模式开关（CR0第0位置1）
    mov eax, cr0
    or eax, 0x00000001
    mov cr0, eax

    ; ------------------------------------------------------------------------------------------------------
    ; ------------------------   当前已开启保护模式（当前还是16位编码，即处于16位保护模式）   ------------------------
    ; ------------------------------------------------------------------------------------------------------
    jmp SELECTOR_CODE:protected_model_start   ; 无条件跳转可刷新流水线

; ------------------------
; 打印字符串
; ------------------------
; 参数：
;   si => 字符串起始地址（以\0标识字符串结尾）
; ------------------------
print:
    ; -----------------------------------------------------
    ; 10H中断 EH号功能 输出字符(光标跟随字符移动)
    ; -----------------------------------------------------
    ; 输入：
    ;   AH => 功能号
    ;   AL => 字符
    ;   BH => 页码
    ;   BL => 颜色（只适用于图形模式）
    ; -----------------------------------------------------
    ; 输出：
    ;   无
    ; ----------------------------------
    mov ah, 0x0e
    mov bx, 0x0001
.loop:
    mov al, [si]
    cmp al, 0
    jz .done
    int 0x10
    inc si
    jmp .loop
.done:
    ret


; ------------------------------------------------------------------------------------------------------
; -----------------------------------   以下程序处于32位保护模式下执行   ------------------------------------
; ------------------------------------------------------------------------------------------------------
[bits 32]
protected_model_start:
    mov ax, SELECTOR_DATA
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ax, SELECTOR_STACK
    mov ss, ax
    mov esp, 0x9fbff

    ; 将内核入口程序读入内存
    mov edi, TOC_ADDR
    mov ecx, TOC_SECTOR_START
    mov bl, TOC_SECTOR_NUM
    call read_hd

    jmp dword SELECTOR_CODE:TOC_ADDR

; -----------------------------------------------------
; 读取硬盘n个扇区，装载到指定内存中
; -----------------------------------------------------
; edi => 将数据写入的内存地址
; ebx => LBA起始扇区号
; cl => 读入的扇区数
; -----------------------------------------------------
read_hd:
    ; -----------------------------------------------------
    ; 硬盘控制器主要端口寄存器说明：
    ;   ---------------------------------------------
    ;   | IO端口Primary通道 | 读端口用途    | 写端口用途 |
    ;   | 0x1F0            |          Data          |
    ;   | 0x1F1            |  Error      | Features |
    ;   | 0x1F2            |      Sector count      |
    ;   | 0x1F3            |      LBA low (0~7)     |
    ;   | 0x1F4            |      LBA mid (8~15)    |
    ;   | 0x1F5            |      LBA high (16~23)  |
    ;   | 0x1F6            |         Device         |
    ;   | 0x1F7            |  Status     | Command  |
    ;   ---------------------------------------------
    ; 端口写指令：
    ;   out dx, ax/al ; dx为端口，写到端口的数据用ax/al存放
    ; 端口读指令：
    ;   in ax/al, dx ; dx为端口，ax/al用来存储读出的数据
    ; 说明：
    ;   Data寄存器宽度16位，其他均为8位，使用ax还是al取决于端口位宽
    ; -----------------------------------------------------
    ; Device寄存器结构：
    ;   -------------------------------------------------
    ;   |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
    ;   |  1  | MOD |  1  | DEV |    LBA地址的24~27位    |
    ;   -------------------------------------------------
    ; MOD:
    ;   寻址模式，0-CHS，1-LBA
    ; DEV:
    ;   选择磁盘，0-主盘（master），1-从盘（slave）
    ; -----------------------------------------------------
    ; Command = 0x20 为读盘命令，Command命令执行前其他参数应设置完毕
    ; -----------------------------------------------------

    ; 设置要读取的扇区数
    mov dx, 0x1f2
    mov al, bl
    out dx, al

    ; 设置LBA低8位
    mov eax, ecx
    inc dx
    out dx, al

    ; 设置LBA中8位
    shr eax, 8
    inc dx
    out dx, al

    ; 设置LBA高8位
    shr eax, 8
    inc dx
    out dx, al

    ; 设置LBA顶4位，及读盘模式
    shr eax, 8
    and al, 0x0f ; al高四位置0，al低四位为LBA第24~27位
    or al, 0xe0 ; al高四位设置为1110，表示LBA模式读取主盘
    inc dx
    out dx, al

    ; 发送读盘命令
    inc dx ; 0x1F7
    mov al, 0x20
    out dx, al

    ; -----------------------------------------------------
    ; 检测硬盘状态
    ; -----------------------------------------------------
    ;   -------------------------------------------------
    ;   |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
    ;   | BSY | RDY | WFT | SKC | DRQ | COR | IDX | ERR |
    ;   -------------------------------------------------
    ; BSY：硬盘是否繁忙
    ; DRQ：是否正在等待写入数据或等待读出数据
    ; RDY：控制器是否已准备好接收命令
    ; WFT：是否存在写故障
    ; ERR：是否有错误发生
    ; -----------------------------------------------------
    ; 注：一次检测只保证一个扇区
    ; -----------------------------------------------------
.check:
    mov dx, 0x1f7
    in al, dx ; 读硬盘状态
    and al, 0x88 ; 第3位为1表示已准备好数据，第7位为1表示硬盘忙
    cmp al, 0x08 ; 判断是否准备好数据
    jnz .check ; 没准备好继续循环

    ; 准备就绪，开始读盘
    mov dx, 0x1f0
    mov ecx, 256 ; 一个扇区512字节，每次读一个字(2字节)
.read:
    in ax, dx
    mov [edi], ax ; 装载到指定内存区域
    add edi, 2
    loop .read

    ; 一个扇区读取完成，准备检测下一个扇区
    dec bl
    ja .check ; bl大于0则继续检测
    ret
